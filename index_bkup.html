<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ìœ ë‹› êµì „ ì‹œë®¬ë ˆì´í„° v0.0.1</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; overflow: hidden; background-color: #1e293b; }
        .log-entry { padding: 2px 0; border-bottom: 1px solid #334155; font-size: 11px; color: #cbd5e1; }
        .log-attack { color: #f87171; }
        .log-defend { color: #60a5fa; }
        .log-evade { color: #4ade80; }
        .log-info { color: #94a3b8; }
        .log-sys { color: #a78bfa; font-style: italic; }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        input[type=number] { padding: 1px 4px; font-size: 0.85em; height: 1.5rem; }
        label { font-size: 0.75rem; color: #94a3b8; }
        select { color: #1e293b; }
    </style>
</head>
<body class="bg-slate-900 h-screen flex flex-col text-slate-200">

    <!-- Header & Controls -->
    <header class="bg-slate-800 shadow p-2 flex justify-between items-center z-10 h-12 border-b border-slate-700">
        <h1 class="text-base font-bold text-white ml-2"><i class="fa-solid fa-swords"></i> ìœ ë‹› êµì „ ì‹œë®¬ë ˆì´í„° v1.7</h1>
        <div class="flex gap-2 items-center">
            <span class="text-xs text-slate-400 mr-2">Space: ì¼ì‹œì •ì§€</span>
            <button id="btnPause" class="px-3 py-0.5 bg-yellow-600 text-white rounded text-sm hover:bg-yellow-500 font-bold transition">ì¼ì‹œì •ì§€</button>
            <button id="btnReset" class="px-3 py-0.5 bg-slate-600 text-white rounded text-sm hover:bg-slate-500 transition">ë¦¬ì…‹</button>
            <select id="speedSelect" class="border rounded px-2 py-0.5 text-sm bg-white text-black">
                <option value="0.1">x0.1 (ë¶„ì„)</option>
                <option value="0.5">x0.5 (ëŠë¦¼)</option>
                <option value="1.0" selected>x1.0 (ì •ìƒ)</option>
                <option value="2.0">x2.0 (ë¹ ë¦„)</option>
                <option value="10.0">x10.0 (ì´ˆê³ ì†)</option>
            </select>
        </div>
    </header>

    <!-- Main Content -->
    <div class="flex flex-1 overflow-hidden">
        
        <!-- Left: Settings Panel -->
        <div class="w-[450px] bg-slate-800 border-r border-slate-700 overflow-y-auto flex flex-col shadow-lg z-10">
            <div class="p-3 space-y-4">
                
                <!-- Unit Settings -->
                <div class="grid grid-cols-2 gap-2">
                    <!-- Blue Team -->
                    <div class="bg-slate-700/50 p-2 rounded border border-blue-900">
                        <div class="flex justify-between items-center mb-1">
                            <h3 class="font-bold text-blue-400 text-xs">Blue Team</h3>
                            <select id="preset_A" class="text-[10px] border rounded w-20 text-black">
                                <option value="">ì„ íƒ...</option>
                            </select>
                        </div>
                        <div class="space-y-1">
                            <div class="flex justify-between"><label>ì²´ë ¥</label><input type="number" id="hp_A" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ê³µê²©ë ¥</label><input type="number" id="atk_A" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ê³µì†</label><input type="number" id="as_A" step="0.1" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ì‚¬ê±°ë¦¬</label><input type="number" id="rng_A" step="0.1" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ë°©íŒ¨</label><input type="number" id="shd_A" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ê°‘ì˜·</label><input type="number" id="arm_A" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ì‚¬ê¸°</label><input type="number" id="mor_A" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ìŠ¤í…Œë¯¸ë„ˆ</label><input type="number" id="mst_A" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ì´ë™ì†ë„</label><input type="number" id="spd_A" class="w-16 border rounded text-right text-black"></div>
                        </div>
                    </div>

                    <!-- Red Team -->
                    <div class="bg-slate-700/50 p-2 rounded border border-red-900">
                        <div class="flex justify-between items-center mb-1">
                            <h3 class="font-bold text-red-400 text-xs">Red Team</h3>
                            <select id="preset_B" class="text-[10px] border rounded w-20 text-black">
                                <option value="">ì„ íƒ...</option>
                            </select>
                        </div>
                        <div class="space-y-1">
                            <div class="flex justify-between"><label>ì²´ë ¥</label><input type="number" id="hp_B" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ê³µê²©ë ¥</label><input type="number" id="atk_B" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ê³µì†</label><input type="number" id="as_B" step="0.1" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ì‚¬ê±°ë¦¬</label><input type="number" id="rng_B" step="0.1" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ë°©íŒ¨</label><input type="number" id="shd_B" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ê°‘ì˜·</label><input type="number" id="arm_B" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ì‚¬ê¸°</label><input type="number" id="mor_B" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ìŠ¤í…Œë¯¸ë„ˆ</label><input type="number" id="mst_B" class="w-16 border rounded text-right text-black"></div>
                            <div class="flex justify-between"><label>ì´ë™ì†ë„</label><input type="number" id="spd_B" class="w-16 border rounded text-right text-black"></div>
                        </div>
                    </div>
                </div>

                <button id="btnApply" class="w-full bg-indigo-600 text-white py-1.5 rounded shadow hover:bg-indigo-500 font-bold text-xs transition">
                    <i class="fa-solid fa-play"></i> ì ìš© ë° ì‹œì‘
                </button>

                <!-- Global Config -->
                <div class="bg-slate-700/50 p-2 rounded border border-slate-600 space-y-3">
                    <h3 class="font-bold text-slate-300 text-xs border-b border-slate-600 pb-1">âš™ï¸ í–‰ë™ ê²°ì • (AI)</h3>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                        <div class="flex justify-between items-center"><label>ìµœëŒ€ ê³µê²©í™•ë¥ </label><input type="number" id="cfg_atk_prob_max" value="1.0" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>ìµœì†Œ ê³µê²©í™•ë¥ </label><input type="number" id="cfg_atk_prob_min" value="0.3" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center col-span-2"><label>ì‚¬ê¸° ì„ê³„ê°’ (ì´í•˜ì¼ë•Œ ìµœì†Œí™•ë¥ )</label><input type="number" id="cfg_morale_threshold" value="0.2" step="0.1" class="w-16 border text-right text-black"></div>
                    </div>

                    <h3 class="font-bold text-slate-300 text-xs border-b border-slate-600 pb-1">âš™ï¸ ì „íˆ¬ ë°¸ëŸ°ìŠ¤</h3>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                        <div class="flex justify-between items-center" title="0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ì˜í–¥ì—†ìŒ"><label class="text-indigo-300 font-bold">ì‚¬ê¸° ì˜í–¥ë ¥(0~1)</label><input type="number" id="cfg_morale_inf" value="0.4" step="0.1" class="w-16 border text-right text-black bg-indigo-50"></div>
                        <div class="flex justify-between items-center" title="0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ì˜í–¥ì—†ìŒ"><label class="text-indigo-300 font-bold">ìŠ¤í…Œë¯¸ë„ˆ ì˜í–¥ë ¥</label><input type="number" id="cfg_stamina_inf" value="0.3" step="0.1" class="w-16 border text-right text-black bg-indigo-50"></div>
                        <div class="flex justify-between items-center"><label>ê¸°ë³¸ íšŒí”¼ìœ¨</label><input type="number" id="cfg_base_evade" value="0.1" step="0.05" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>íšŒí”¼ ì„ íƒ ë³´ì •(x)</label><input type="number" id="cfg_evade_bonus" value="2.0" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>ë°©ì–´ ì„ íƒ ë³´ì •(x)</label><input type="number" id="cfg_def_bonus" value="1.5" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>ë°©íŒ¨ íšŒí”¼ í˜ë„í‹°</label><input type="number" id="cfg_shield_pen" value="0.5" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>ê°‘ì˜· íšŒí”¼ í˜ë„í‹°</label><input type="number" id="cfg_armor_pen" value="0.5" step="0.1" class="w-16 border text-right text-black"></div>
                    </div>

                    <h3 class="font-bold text-slate-300 text-xs border-b border-slate-600 pb-1">âš™ï¸ ì¸í„°ë²Œ & ë¹„ìš©</h3>
                    <div class="grid grid-cols-2 gap-x-4 gap-y-1">
                        <div class="flex justify-between items-center"><label>ê³µê²© ì „ ë”œë ˆì´</label><input type="number" id="cfg_pre_delay" value="0.5" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>íšŒí”¼ í›„ ì¸í„°ë²Œ</label><input type="number" id="cfg_interval_evade" value="0.5" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>ë°©ì–´ í›„ ì¸í„°ë²Œ</label><input type="number" id="cfg_interval_block" value="0.8" step="0.1" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>ê³µê²© ìŠ¤í…Œë¯¸ë„ˆ</label><input type="number" id="cfg_attack_cost" value="10" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>íšŒí”¼ ìŠ¤í…Œë¯¸ë„ˆ</label><input type="number" id="cfg_evade_cost" value="5" class="w-16 border text-right text-black"></div>
                        <div class="flex justify-between items-center"><label>ìŠ¤í…Œë¯¸ë„ˆ íšŒë³µ/s</label><input type="number" id="cfg_stamina_regen" value="5" class="w-16 border text-right text-black"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Center: Visualizer -->
        <div class="flex-1 bg-slate-900 relative flex justify-center items-center overflow-hidden">
            <canvas id="battleCanvas" class="shadow-2xl rounded-lg bg-slate-950"></canvas>
            
            <!-- Result Overlay -->
            <div id="winnerOverlay" class="absolute inset-0 bg-black/60 backdrop-blur-sm flex flex-col justify-center items-center hidden text-white z-50">
                <h2 id="winnerText" class="text-4xl font-extrabold mb-4 animate-bounce">ìŠ¹ë¦¬!</h2>
                <button id="btnRestart" class="px-6 py-2 bg-white text-black font-bold rounded-full hover:bg-gray-200 transition">ë‹¤ì‹œ í•˜ê¸°</button>
            </div>
        </div>

        <!-- Right: Log -->
        <div class="w-72 bg-slate-800 border-l border-slate-700 flex flex-col shadow-lg z-10">
            <div class="p-2 border-b border-slate-700 font-bold flex justify-between items-center text-slate-300 text-xs">
                <span><i class="fa-solid fa-list-ul"></i> ì „íˆ¬ ë¡œê·¸</span>
                <button id="btnClearLog" class="text-slate-500 hover:text-red-400 transition"><i class="fa-solid fa-trash"></i></button>
            </div>
            <div id="logContainer" class="flex-1 overflow-y-auto p-2 font-mono leading-relaxed space-y-1 bg-slate-800">
                <!-- Logs go here -->
            </div>
        </div>
    </div>

<script>
/**
 * Battle Simulator Logic v1.7 (Merged with Tactical View)
 */

// --- Constants & Config ---
const RANGE_SCALE = 40; 
const UNIT_PRESETS = {
    "ì§•ì§‘ë³‘": { hp: 20, atk: 10, as: 1.0, rng: 1.0, spd: 40, shd: 0, arm: 1, mst: 60, mor: 40 },
    "ê²½ë³´ë³‘": { hp: 30, atk: 15, as: 0.9, rng: 1.0, spd: 45, shd: 3, arm: 2, mst: 65, mor: 60 },
    "ì¤‘ë³´ë³‘": { hp: 35, atk: 15, as: 0.7, rng: 1.2, spd: 35, shd: 5, arm: 5, mst: 75, mor: 80 }
};

const STATES = {
    IDLE: 'ëŒ€ê¸°',
    MOVING: 'ì´ë™',
    PRE_ATTACK: 'ê³µê²©ì¤€ë¹„',
    RECOVER: 'íœ´ì‹',
    INTERVAL: 'í›„ë”œë ˆì´',
    DEFENDING: 'ë°©ì–´íƒœì„¸', 
    DEAD: 'ì‚¬ë§'
};

const INTENTS = {
    NONE: '...',
    ENGAGE: 'ì ‘ê·¼',
    ATTACK: 'ê³µê²©!',
    DEFEND: 'ë°©ì–´ì¤‘',
    REST: 'ìˆ¨ê³ ë¥´ê¸°'
};

// --- Global Config Manager ---
const GlobalConfig = {
    get: () => ({
        // AI Logic
        atkProbMax: Number(document.getElementById('cfg_atk_prob_max').value),
        atkProbMin: Number(document.getElementById('cfg_atk_prob_min').value),
        moraleThreshold: Number(document.getElementById('cfg_morale_threshold').value),
        
        // Damage Influences
        moraleInf: Number(document.getElementById('cfg_morale_inf').value),
        staminaInf: Number(document.getElementById('cfg_stamina_inf').value),

        // Balance
        baseEvade: Number(document.getElementById('cfg_base_evade').value),
        evadeBonus: Number(document.getElementById('cfg_evade_bonus').value),
        defBonus: Number(document.getElementById('cfg_def_bonus').value),
        shieldPen: Number(document.getElementById('cfg_shield_pen').value),
        armorPen: Number(document.getElementById('cfg_armor_pen').value),
        
        // Intervals & Costs
        preDelay: Number(document.getElementById('cfg_pre_delay').value),
        intervalEvade: Number(document.getElementById('cfg_interval_evade').value),
        intervalBlock: Number(document.getElementById('cfg_interval_block').value),
        attackCost: Number(document.getElementById('cfg_attack_cost').value),
        evadeCost: Number(document.getElementById('cfg_evade_cost').value),
        staminaRegen: Number(document.getElementById('cfg_stamina_regen').value),
        moveMult: 1.5
    })
};

// --- Unit Class (Merged) ---
class Unit {
    constructor(id, team, x, y, stats) {
        this.id = id;
        this.team = team;
        this.x = x;
        this.y = y;
        
        // Stats
        this.maxHp = stats.hp;
        this.hp = stats.hp;
        this.atk = stats.atk;
        this.atkSpd = stats.as;
        this.range = stats.rng * RANGE_SCALE;
        this.moveSpeed = stats.spd;
        this.shield = stats.shd;
        this.armor = stats.arm;
        this.maxStamina = stats.mst;
        this.stamina = stats.mst;
        this.maxMorale = stats.mor;
        this.morale = stats.mor;
        
        // State
        this.state = STATES.IDLE;
        this.stateTimer = 0;
        this.intent = INTENTS.ENGAGE;
        
        // Visualization Props
        this.radius = 16;
        this.angle = 0; // ë°”ë¼ë³´ëŠ” ë°©í–¥ (ë¼ë””ì•ˆ)
        
        // Animation Vars
        this.animState = 'IDLE'; // Visual state (ATTACK, DEFEND, etc.)
        this.animTimer = 0;
        this.visualEffects = []; 
        
        this.offsetX = 0; // For attack lunge
        this.shakeX = 0;  // For hit shake
        this.shakeY = 0;
        
        this.shieldScale = 1.0; 
        this.shieldBaseScale = 0.9;
        
        this.showSwipe = false;
        this.hitFlash = 0; 
        this.hitIntensity = 0;
    }

    addTextEffect(value, color) {
        this.visualEffects.push({
            type: 'text',
            value: value,
            color: color || '#fff',
            life: 0.8,
            x: 0, y: -25
        });
    }

    // --- Main Update Loop ---
    update(dt, enemy, config) {
        // 1. Visual & Physics Update (Animation)
        this.updateVisuals(dt);

        if (this.state === STATES.DEAD) return;
        if (this.hp <= 0) { this.die(); return; }

        this.recoverStamina(dt, config);

        // 2. Logic Update
        // Rotate towards enemy if alive
        if (enemy && enemy.state !== STATES.DEAD) {
            const dx = enemy.x - this.x;
            const dy = enemy.y - this.y;
            const targetAngle = Math.atan2(dy, dx);
            // Simple rotation (instant)
            this.angle = targetAngle;
        }

        if (this.stateTimer > 0) {
            this.stateTimer -= dt;
            
            // Visual Windup during PRE_ATTACK
            if (this.state === STATES.PRE_ATTACK) {
                // Calculate progress 0 to 1
                const totalTime = config.preDelay;
                const elapsed = totalTime - this.stateTimer;
                const progress = Math.min(1, elapsed / totalTime);
                
                // Windup: Pull back slightly (-3px)
                // Use Sin for smooth pullback
                this.offsetX = -3 * Math.sin(progress * Math.PI * 0.5);
            }

            if (this.stateTimer <= 0) {
                // Transition logic
                if (this.state === STATES.INTERVAL || this.state === STATES.DEFENDING) {
                    this.decideNextAction(enemy, config);
                } else if (this.state === STATES.PRE_ATTACK) {
                    this.executeAttack(enemy, config);
                }
            } else {
                if(this.state === STATES.DEFENDING) this.intent = INTENTS.DEFEND;
            }
            return; // Busy
        }

        // Logic when not busy
        switch (this.state) {
            case STATES.RECOVER:
                this.intent = INTENTS.REST;
                if (this.stamina >= config.attackCost + 5) this.state = STATES.IDLE;
                break;

            case STATES.IDLE:
            case STATES.MOVING:
                const dist = this.distanceTo(enemy);
                if (dist <= this.range) {
                    if (this.stamina < config.attackCost) {
                        this.state = STATES.RECOVER;
                        sim.log(`${this.teamName()}: ì§€ì¹¨ (íœ´ì‹)`, 'log-info');
                    } else {
                        this.startAttack(config);
                    }
                } else {
                    this.state = STATES.MOVING;
                    this.intent = INTENTS.ENGAGE;
                    this.moveTowards(enemy, dt, config);
                }
                break;
        }
    }

    updateVisuals(dt) {
        // Effects
        this.visualEffects.forEach(e => { e.life -= dt; e.y -= 15 * dt; });
        this.visualEffects = this.visualEffects.filter(e => e.life > 0);

        // Hit Shake & Flash
        if (this.hitFlash > 0) {
            this.hitFlash -= dt * 5; 
            if (this.hitFlash < 0) {
                this.hitFlash = 0;
                this.shakeX = 0;
                this.shakeY = 0;
            } else {
                const shakeMag = Math.min(4, 1 + (this.hitIntensity / 10)) * (this.hitFlash); 
                this.shakeX = (Math.random() - 0.5) * shakeMag * 2;
                this.shakeY = (Math.random() - 0.5) * shakeMag * 2;
            }
        }

        // Attack Animation (Thrust & Recovery)
        if (this.animState === 'ATTACK') {
            this.animTimer += dt;
            const duration = 0.3;
            const progress = Math.min(1, this.animTimer / duration);

            // Thrust -> Recovery
            // Note: Windup happens in PRE_ATTACK logic state
            if (progress < 0.3) {
                // Thrust forward (+10px) fast
                const t = progress / 0.3;
                this.offsetX = -3 + (13 * t); 
                this.showSwipe = true;
            } else {
                // Recovery
                const t = (progress - 0.3) / 0.7;
                this.offsetX = 10 * (1 - t); 
                this.showSwipe = false;
            }

            if (progress >= 1) {
                this.animState = 'IDLE';
                this.offsetX = 0;
                this.showSwipe = false;
            }
        } 
        // Defend Animation
        else if (this.animState === 'DEFEND') {
            this.animTimer += dt;
            const duration = 0.4;
            const progress = Math.min(1, this.animTimer / duration);

            if (progress < 0.2) {
                // Bounce shield
                const t = progress / 0.2;
                this.shieldScale = this.shieldBaseScale + (0.25 * Math.sin(t * Math.PI)); 
            } else {
                this.shieldScale = this.shieldBaseScale;
            }

            if (progress >= 1) {
                this.animState = 'IDLE';
                this.shieldScale = this.shieldBaseScale;
            }
        } 
        else {
            // IDLE Shield Breathing
            // Use safe interpolation
            const diff = this.shieldBaseScale - this.shieldScale;
            if (Math.abs(diff) > 0.001) this.shieldScale += diff * dt * 5;
            else this.shieldScale = this.shieldBaseScale;
            
            // Ensure offsetX returns to 0 if not attacking (e.g. interrupted)
            if (this.state !== STATES.PRE_ATTACK) {
                this.offsetX *= 0.9;
            }
        }
    }

    decideNextAction(enemy, config) {
        const moraleRatio = this.morale / this.maxMorale;
        let atkProb = 0;

        if (moraleRatio <= config.moraleThreshold) {
            atkProb = config.atkProbMin;
        } else {
            atkProb = config.atkProbMin + (moraleRatio - config.moraleThreshold) * (config.atkProbMax - config.atkProbMin) / (1.0 - config.moraleThreshold);
        }

        if (enemy.state === STATES.PRE_ATTACK) atkProb *= 0.5;

        if (Math.random() < atkProb) {
            this.state = STATES.IDLE; 
        } else {
            this.state = STATES.DEFENDING;
            this.stateTimer = 0.5;
            this.intent = INTENTS.DEFEND;
        }
    }

    moveTowards(target, dt, config) {
        if (target.state === STATES.DEAD) return;
        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.hypot(dx, dy);
        
        if (dist <= this.range) {
            this.state = STATES.IDLE;
            return;
        }

        const speed = this.moveSpeed * config.moveMult;
        const moveDist = speed * dt;
        this.x += (dx / dist) * moveDist;
        this.y += (dy / dist) * moveDist;
    }

    recoverStamina(dt, config) {
        if (this.stamina < this.maxStamina) {
            this.stamina = Math.min(this.maxStamina, this.stamina + (config.staminaRegen * dt));
        }
    }

    startAttack(config) {
        this.state = STATES.PRE_ATTACK;
        this.stateTimer = config.preDelay;
        this.intent = INTENTS.ATTACK;
        this.addTextEffect('!', '#fbbf24');
        // Visual windup handled in update()
    }

    executeAttack(enemy, config) {
        if (enemy.state === STATES.DEAD) { this.state = STATES.IDLE; return; }

        // Trigger Visual Attack (The strike)
        this.animState = 'ATTACK';
        this.animTimer = 0;

        // Damage Calculation
        const moraleRatio = this.morale / this.maxMorale;
        const staminaRatio = this.stamina / this.maxStamina;

        const moraleFactor = (1 - config.moraleInf) + (config.moraleInf * Math.max(0, moraleRatio));
        const staminaFactor = (1 - config.staminaInf) + (config.staminaInf * Math.max(0, staminaRatio));
        
        let rawDamage = this.atk * moraleFactor * staminaFactor; 
        
        this.stamina -= config.attackCost;

        sim.log(`${this.teamName()}: ê³µê²© (ìœ„ë ¥ ${rawDamage.toFixed(1)})`, 'log-attack');
        
        enemy.receiveAttack(rawDamage, this, config);

        // Interval
        const intervalTime = 1 / this.atkSpd;
        this.state = STATES.INTERVAL;
        this.stateTimer = intervalTime;
        this.intent = INTENTS.NONE;
    }

    receiveAttack(damage, attacker, config) {
        const canAct = (this.state === STATES.IDLE || this.state === STATES.DEFENDING || this.state === STATES.MOVING);
        
        // Forced Hit
        if (!canAct) {
             this.applyDamage(damage, false, config);
             return;
        }

        const canBlock = this.shield > 0;
        const lowStamina = this.stamina < config.evadeCost;
        const isDefending = (this.state === STATES.DEFENDING);
        
        let choice = 'NONE';
        if (lowStamina) {
            choice = canBlock ? 'BLOCK' : 'NONE';
        } else {
            let blockChance = canBlock ? (isDefending ? 0.9 : 0.7) : 0;
            choice = Math.random() < blockChance ? 'BLOCK' : 'EVADE';
        }

        // 1. Evade
        if (choice === 'EVADE') {
            const shieldPen = 1 - (this.shield / 20 * config.shieldPen);
            const armorPen = 1 - (this.armor / 20 * config.armorPen);
            const stamRatio = this.stamina / this.maxStamina;
            let evadeMult = config.evadeBonus;
            
            let chance = config.baseEvade * evadeMult * stamRatio * Math.max(0, shieldPen) * Math.max(0, armorPen);

            if (Math.random() < chance) {
                this.stamina -= config.evadeCost;
                
                const morRec = this.maxMorale * 0.33;
                this.morale = Math.min(this.maxMorale, this.morale + morRec);
                
                this.addTextEffect('íšŒí”¼!', '#4ade80');
                sim.log(`${this.teamName()}: íšŒí”¼ ì„±ê³µ! (ì‚¬ê¸° +${morRec.toFixed(1)})`, 'log-evade');
                
                // Visual Slide Back
                const dx = this.x - attacker.x;
                const dy = this.y - attacker.y;
                const dist = Math.hypot(dx, dy);
                if(dist>0) { 
                    // Move unit physics position slightly instead of just visual offset
                    // to keep distance logic consistent
                    this.x += (dx/dist)*15;
                    this.y += (dy/dist)*15;
                }

                this.state = STATES.INTERVAL;
                this.stateTimer = config.intervalEvade;
                this.intent = INTENTS.NONE;
                return;
            } else {
                sim.log(`${this.teamName()}: íšŒí”¼ ì‹¤íŒ¨ (í™•ë¥  ${(chance*100).toFixed(0)}%)`, 'log-info');
            }
        } 
        
        // 2. Block
        if (choice === 'BLOCK' || (choice === 'EVADE' && canBlock)) {
            let defBonus = (choice === 'BLOCK' || isDefending) ? config.defBonus : 1.0;
            
            const shieldDef = this.shield * 0.8 * defBonus;
            const armorDef = this.armor * 0.5;
            const totalDef = shieldDef + armorDef;
            
            const finalDmg = Math.max(0, damage - totalDef);
            
            this.hp -= finalDmg;
            this.applyMoraleDamage(finalDmg);

            this.addTextEffect(`ë°©ì–´ ${finalDmg.toFixed(0)}`, '#60a5fa');
            sim.log(`${this.teamName()}: ë°©ì–´ (ê°ì‡„ ${totalDef.toFixed(1)}) -> í”¼í•´ ${finalDmg.toFixed(1)}`, 'log-defend');
            
            // Trigger Visual Defend
            this.animState = 'DEFEND';
            this.animTimer = 0;
            this.shieldScale = 0.85;

            this.state = STATES.INTERVAL;
            this.stateTimer = config.intervalBlock;
            this.intent = INTENTS.NONE;
            return;
        }

        // 3. Full Damage
        this.applyDamage(damage, true, config);
    }

    applyDamage(damage, passiveMitigation, config) {
        let finalDmg = damage;
        if (passiveMitigation) {
            finalDmg = Math.max(0, damage - (this.armor * 0.5));
        }
        
        this.hp -= finalDmg;
        this.applyMoraleDamage(finalDmg);
        
        // Trigger Hit Visual
        this.hitIntensity = finalDmg;
        this.hitFlash = 1.0;
        
        this.addTextEffect(`-${finalDmg.toFixed(1)}`, '#f87171');
        sim.log(`${this.teamName()}: í”¼ê²© ${finalDmg.toFixed(1)}`, 'log-attack');
    }

    applyMoraleDamage(dmg) {
        const loss = (dmg / this.maxHp) * 30; 
        this.morale = Math.max(0, this.morale - loss);
    }

    die() {
        this.state = STATES.DEAD;
        sim.log(`${this.teamName()}: ì‚¬ë§ (ì‚¬ê¸° 0)`, 'log-attack font-bold');
        sim.endGame(this.team === 'A' ? 'B' : 'A');
    }

    distanceTo(other) { return Math.hypot(other.x - this.x, other.y - this.y); }
    teamName() { return this.team === 'A' ? 'ğŸ”µ' : 'ğŸ”´'; }

    // --- DRAWING LOGIC (From Tactical Design) ---
    draw(ctx) {
        ctx.save();
        
        // 1. Position & Rotation
        const drawX = this.x + this.shakeX;
        const drawY = this.y + this.shakeY;

        ctx.translate(drawX, drawY);
        ctx.rotate(this.angle);
        ctx.translate(this.offsetX, 0); // Lunge

        const isDead = (this.state === STATES.DEAD);

        // --- Color Logic ---
        let finalColor, highlightColor;

        if (isDead) {
            if (this.team === 'A') {
                finalColor = "rgb(45, 65, 100)"; 
                highlightColor = "rgb(65, 85, 120)"; 
            } else {
                finalColor = "rgb(100, 45, 45)";
                highlightColor = "rgb(120, 65, 65)";
            }
        } else {
            // Hit Flash (White)
            if (this.hitFlash > 0) {
                const t = this.hitFlash * 0.8; 
                
                const moraleRatio = this.morale / this.maxMorale;
                const colorRetention = 0.3 + (0.7 * moraleRatio);
                const baseColor = this.team === 'A' ? {r:59, g:130, b:246} : {r:239, g:68, b:68};
                const grayColor = {r:100, g:116, b:139};
                
                const rBase = Math.round(grayColor.r + (baseColor.r - grayColor.r) * colorRetention);
                const gBase = Math.round(grayColor.g + (baseColor.g - grayColor.g) * colorRetention);
                const bBase = Math.round(grayColor.b + (baseColor.b - grayColor.b) * colorRetention);

                const r = Math.round(rBase + (255 - rBase) * t);
                const g = Math.round(gBase + (255 - gBase) * t);
                const b = Math.round(bBase + (255 - bBase) * t);
                
                finalColor = `rgb(${r},${g},${b})`;
                highlightColor = "#ffffff";
            } else {
                const moraleRatio = this.morale / this.maxMorale;
                const colorRetention = 0.3 + (0.7 * moraleRatio);
                const baseColor = this.team === 'A' ? {r:59, g:130, b:246} : {r:239, g:68, b:68};
                const grayColor = {r:100, g:116, b:139};

                const r = Math.round(grayColor.r + (baseColor.r - grayColor.r) * colorRetention);
                const g = Math.round(grayColor.g + (baseColor.g - grayColor.g) * colorRetention);
                const b = Math.round(grayColor.b + (baseColor.b - grayColor.b) * colorRetention);
                finalColor = `rgb(${r},${g},${b})`;
                highlightColor = this.lightenColor(r, g, b, 40);
            }
        }

        // Shadow
        ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
        ctx.shadowBlur = isDead ? 2 : 8;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        // Swipe Effect
        if (this.showSwipe) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(6, 0, this.radius + 8, -Math.PI/3, Math.PI/3);
            ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
            ctx.lineWidth = 8; 
            ctx.lineCap = "round";
            ctx.stroke();
            ctx.restore();
        }

        // Body
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        const gradient = ctx.createRadialGradient(-5, -5, 2, 0, 0, this.radius);
        gradient.addColorStop(0, highlightColor);
        gradient.addColorStop(1, finalColor);
        ctx.fillStyle = gradient;
        ctx.fill();

        // Border & Stamina
        if (isDead) {
            if (this.team === 'A') ctx.strokeStyle = "#475569"; 
            else ctx.strokeStyle = "#5c4848"; 
            ctx.lineWidth = 1.5; 
            ctx.stroke();
        } else {
            const staminaRatio = this.stamina / this.maxStamina;
            const alpha = 0.3 + (0.7 * staminaRatio);
            const lineWidth = 1 + (2 * staminaRatio);
            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            ctx.lineWidth = lineWidth;
            ctx.stroke();
        }

        ctx.shadowColor = "transparent";

        if (!isDead) {
            const moraleRatio = this.morale / this.maxMorale;
            
            // Direction Arrow
            ctx.beginPath();
            const arrowDist = this.radius - 3;
            ctx.moveTo(arrowDist, 0);
            ctx.lineTo(arrowDist - 7, -5);
            ctx.lineTo(arrowDist - 7, 5);
            ctx.closePath();
            ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + 0.5 * moraleRatio})`;
            ctx.fill();

            // Shield
            if (this.shield > 0) {
                const s = Math.max(0.1, this.shieldScale); 
                const shieldR = this.radius + 6;
                const isBlocking = s > 1.0; 
                const shieldColor = isBlocking ? "#fffbeb" : "#fbbf24"; 
                const shieldWidth = isBlocking ? 4 : 3; 

                ctx.beginPath();
                ctx.arc(s * 1, 0, shieldR * s, -Math.PI/4, Math.PI/4);
                ctx.strokeStyle = shieldColor; 
                ctx.lineWidth = shieldWidth;
                ctx.lineCap = "round";
                ctx.stroke();
                
                if (!isBlocking) {
                    ctx.beginPath();
                    ctx.arc(s*1, 0, shieldR * s, -Math.PI/8, 0);
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        ctx.restore();

        // HP Bar & Intent (Non-rotating)
        if (!isDead) {
            // HP Bar
            const barX = drawX - 16; 
            const barY = drawY + this.radius + 10;
            const barW = 32;
            const barH = 5;

            ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
            ctx.fillRect(barX, barY, barW, barH);
            
            const hpPercent = this.hp / this.maxHp;
            let hpColor = "#22c55e"; 
            if(hpPercent < 0.5) hpColor = "#eab308"; 
            if(hpPercent < 0.2) hpColor = "#ef4444"; 

            ctx.fillStyle = hpColor;
            ctx.fillRect(barX, barY, barW * hpPercent, barH);
            
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);

            // Intent Bubble
            ctx.fillStyle = 'rgba(255,255,255,0.85)';
            const bubbleX = drawX - 30;
            const bubbleY = drawY - 45;
            
            ctx.beginPath(); 
            if (ctx.roundRect) {
                ctx.roundRect(bubbleX, bubbleY, 60, 18, 4);
            } else {
                ctx.rect(bubbleX, bubbleY, 60, 18);
            }
            ctx.fill();
            ctx.fillStyle = '#1e293b'; ctx.font = 'bold 9px sans-serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.intent, drawX, bubbleY + 9);

            // Floating Text Effects
            this.visualEffects.forEach(e => {
                ctx.save(); ctx.globalAlpha = e.life;
                ctx.font = 'bold 12px sans-serif'; ctx.fillStyle = e.color;
                ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
                ctx.strokeText(e.value, drawX + e.x, drawY + e.y);
                ctx.fillText(e.value, drawX + e.x, drawY + e.y);
                ctx.restore();
            });
        }
    }

    lightenColor(r, g, b, amt) {
        var nr = r + amt; if (nr > 255) nr = 255; else if (nr < 0) nr = 0;
        var ng = g + amt; if (ng > 255) ng = 255; else if (ng < 0) ng = 0;
        var nb = b + amt; if (nb > 255) nb = 255; else if (nb < 0) nb = 0;
        return `rgb(${nr},${ng},${nb})`;
    }
}

// --- Simulator Engine ---
class BattleSimulator {
    constructor() {
        this.canvas = document.getElementById('battleCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.logContainer = document.getElementById('logContainer');
        
        this.units = [];
        this.running = false;
        this.paused = false;
        this.lastTime = 0;
        this.timeScale = 1.0;
        this.elapsedTime = 0;

        this.initPresets();
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') { e.preventDefault(); this.togglePause(); }
        });
    }

    initPresets() {
        const selA = document.getElementById('preset_A');
        const selB = document.getElementById('preset_B');
        
        for (let name in UNIT_PRESETS) {
            let optA = document.createElement('option');
            optA.value = name; optA.innerText = name;
            selA.appendChild(optA);
            
            let optB = document.createElement('option');
            optB.value = name; optB.innerText = name;
            selB.appendChild(optB);
        }
        this.loadPreset('A', 'ì§•ì§‘ë³‘');
        this.loadPreset('B', 'ê²½ë³´ë³‘');
    }

    loadPreset(team, presetName) {
        if (!presetName) return;
        const stats = UNIT_PRESETS[presetName];
        const setVal = (id, val) => document.getElementById(id).value = val;
        
        setVal(`hp_${team}`, stats.hp);
        setVal(`atk_${team}`, stats.atk);
        setVal(`as_${team}`, stats.as);
        setVal(`rng_${team}`, stats.rng);
        setVal(`spd_${team}`, stats.spd);
        setVal(`shd_${team}`, stats.shd);
        setVal(`arm_${team}`, stats.arm);
        setVal(`mst_${team}`, stats.mst);
        setVal(`mor_${team}`, stats.mor);
    }

    resize() {
        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
        this.render();
    }

    log(msg, className = '') {
        const time = `[${(this.elapsedTime).toFixed(1)}s] `;
        const div = document.createElement('div');
        div.className = `log-entry ${className}`;
        div.innerHTML = `<span class="text-slate-500 text-[10px]">${time}</span> ${msg}`;
        this.logContainer.appendChild(div);
        this.logContainer.scrollTop = this.logContainer.scrollHeight;
    }

    getStats(team) {
        return {
            hp: Number(document.getElementById(`hp_${team}`).value),
            atk: Number(document.getElementById(`atk_${team}`).value),
            as: Number(document.getElementById(`as_${team}`).value),
            rng: Number(document.getElementById(`rng_${team}`).value),
            spd: Number(document.getElementById(`spd_${team}`).value),
            shd: Number(document.getElementById(`shd_${team}`).value),
            arm: Number(document.getElementById(`arm_${team}`).value),
            mst: Number(document.getElementById(`mst_${team}`).value),
            mor: Number(document.getElementById(`mor_${team}`).value),
        };
    }

    applyStats() {
        this.reset();
        const cx = this.canvas.width / 2;
        const cy = this.canvas.height / 2;
        
        const statsA = this.getStats('A');
        const statsB = this.getStats('B');
        
        // Spawn distance: Range of A + Range of B + Buffer
        const spawnDist = (statsA.rng * RANGE_SCALE) + (statsB.rng * RANGE_SCALE) + 100;
        
        this.units = [
            new Unit(1, 'A', cx - spawnDist/2, cy, statsA),
            new Unit(2, 'B', cx + spawnDist/2, cy, statsB)
        ];
        
        // Default facing
        this.units[0].angle = 0;
        this.units[1].angle = Math.PI;
        
        this.log("ì „íˆ¬ ì‹œì‘", "font-bold text-center mt-2 mb-2 bg-slate-700");
        this.start();
    }

    start() {
        if (this.running) return;
        this.running = true;
        this.paused = false;
        this.lastTime = performance.now();
        document.getElementById('winnerOverlay').classList.add('hidden');
        requestAnimationFrame((t) => this.loop(t));
    }

    reset() {
        this.running = false;
        this.elapsedTime = 0;
        this.units = [];
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.logContainer.innerHTML = '';
        document.getElementById('btnPause').innerText = "ì¼ì‹œì •ì§€";
        document.getElementById('winnerOverlay').classList.add('hidden');
    }

    togglePause() {
        this.paused = !this.paused;
        const btn = document.getElementById('btnPause');
        btn.innerText = this.paused ? "ì¬ê°œ" : "ì¼ì‹œì •ì§€";
        btn.classList.toggle('bg-yellow-600');
        btn.classList.toggle('bg-green-600');
        if (!this.paused) {
            this.lastTime = performance.now();
            requestAnimationFrame((t) => this.loop(t));
        }
    }

    setSpeed(val) { this.timeScale = parseFloat(val); }

    endGame(winnerTeam) {
        this.running = false;
        const overlay = document.getElementById('winnerOverlay');
        const text = document.getElementById('winnerText');
        overlay.classList.remove('hidden');
        
        if (winnerTeam === 'A') {
            text.innerText = "Blue Team ìŠ¹ë¦¬!";
            text.className = "text-4xl font-extrabold mb-4 animate-bounce text-blue-400";
        } else {
            text.innerText = "Red Team ìŠ¹ë¦¬!";
            text.className = "text-4xl font-extrabold mb-4 animate-bounce text-red-400";
        }
    }

    loop(timestamp) {
        if (!this.running || this.paused) return;
        const dtRaw = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        const dt = Math.min(dtRaw, 0.1) * this.timeScale;
        this.elapsedTime += dt;

        const config = GlobalConfig.get();
        const unitA = this.units[0];
        const unitB = this.units[1];

        if (unitA && unitB) {
            unitA.update(dt, unitB, config);
            unitB.update(dt, unitA, config);
        }

        this.render();
        requestAnimationFrame((t) => this.loop(t));
    }

    render() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Grid
        ctx.strokeStyle = "#334155";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i=0; i<this.canvas.width; i+=40) { ctx.moveTo(i,0); ctx.lineTo(i,this.canvas.height); }
        for(let i=0; i<this.canvas.height; i+=40) { ctx.moveTo(0,i); ctx.lineTo(this.canvas.width,i); }
        ctx.stroke();

        this.units.forEach(u => {
            u.draw(ctx);
        });
    }
}

// Global instance
const sim = new BattleSimulator();

// UI Event Listeners
document.getElementById('btnApply').onclick = () => sim.applyStats();
document.getElementById('btnPause').onclick = () => sim.togglePause();
document.getElementById('btnReset').onclick = () => sim.reset();
document.getElementById('speedSelect').onchange = (e) => sim.setSpeed(e.target.value);
document.getElementById('preset_A').onchange = (e) => sim.loadPreset('A', e.target.value);
document.getElementById('preset_B').onchange = (e) => sim.loadPreset('B', e.target.value);
document.getElementById('btnRestart').onclick = () => sim.applyStats();
document.getElementById('btnClearLog').onclick = () => {
    document.getElementById('logContainer').innerHTML = '';
};

// Global access
window.sim = sim;
</script>
</body>
</html>